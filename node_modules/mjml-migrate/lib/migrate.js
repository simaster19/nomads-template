'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = migrate;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _config = require('./config');

var _mjml2json = require('mjml2json');

var _mjml2json2 = _interopRequireDefault(_mjml2json);

var _json2mjml = require('json2mjml');

var _json2mjml2 = _interopRequireDefault(_json2mjml);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function removeContainerTag(bodyTag) {
  bodyTag.attributes = bodyTag.children[0].attributes;
  bodyTag.children = bodyTag.children[0].children;

  return bodyTag;
}

var listAttributes = function listAttributes(tag) {
  return tag.attributes;
};

function fixUnits(attribute, value) {
  var length = _config.attributesWithUnit.length;
  for (var i = 0; i < length; i++) {
    if (_config.attributesWithUnit[i] === attribute) {
      return addPx(value);
    }
  }
  return value;
}

function addPx(value) {
  if (!isNaN(value)) {
    return value + 'px';
  } else {
    return value;
  }
}

function cleanAttributes(attributes) {
  for (var key in attributes) {
    attributes[key] = fixUnits(key, attributes[key]);
  }
  return attributes;
}

function migrateSocialSyntax(socialTag) {
  var listAllNetworks = function listAllNetworks(tag) {
    var attributes = tag.attributes['display'].split(' ');
    delete tag.attributes['display'];
    return attributes;
  };

  var attributes = listAttributes(socialTag);
  delete attributes['display'];

  var networks = listAllNetworks(socialTag);
  socialTag.children = [];

  // migrate all attributes to their child attributes
  for (var network in networks) {
    socialTag.children.push({
      tagName: 'mj-social-element',
      attributes: { "name": networks[network] },
      content: attributes[networks[network] + '-content'] ? attributes[networks[network] + '-content'] : ''
    });

    for (var attribute in attributes) {
      if (attribute.match(networks[network]) && !attribute.match('content')) {
        socialTag.children[network].attributes[attribute.replace(networks[network] + '-', '')] = socialTag.attributes[attribute];
        delete socialTag.attributes[attribute];
      }
    }
  }

  // delete all content attributes from the root tag after they've been migrated
  for (var _attribute in attributes) {
    if (_attribute.match('content')) {
      delete attributes[_attribute];
    }
  }

  return socialTag;
}

function migrateHeroSyntax(heroTag) {
  var contentAttributes = listAttributes(heroTag.children[0]);

  for (var attribute in contentAttributes) {
    console.log(attribute);
    heroTag.attributes[attribute] = heroTag.children[0].attributes[attribute];
  }

  heroTag.children = heroTag.children[0].children;
  return heroTag;
}

function isSupportedTag(tag) {
  var length = _config.unavailableTags.length;
  for (var i = 0; i < length; i++) {
    if (tag === _config.unavailableTags[i]) {
      return false;
    }
  }
  return true;
}

function loopThrough(tree) {
  for (var key in tree) {
    if (key === 'children') {
      for (var i = 0; i < tree.children.length; i++) {
        if (isSupportedTag(tree.children[i].tagName)) {
          if (tree.children[i].tagName === 'mj-body') {
            tree.children[i] = removeContainerTag(tree.children[i]);
          } else if (tree.children[i].tagName === 'mj-social') {
            tree.children[i] = migrateSocialSyntax(tree.children[i]);
          } else if (tree.children[i].tagName === 'mj-hero') {
            tree.children[i] = migrateHeroSyntax(tree.children[i]);
          }
          tree.children[i].attributes = cleanAttributes(tree.children[i].attributes);
          loopThrough(tree.children[i]);
        } else {
          delete tree.children[i];
        }
      }
    }
  }
}

function migrate(input) {
  var mjmlJson = (0, _mjml2json2.default)(input);
  loopThrough(mjmlJson);

  return (0, _json2mjml2.default)(mjmlJson);
}